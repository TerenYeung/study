# 算法与数据结构

## 算法

### 什么是算法

算法是解决问题的一系列步骤；

计算机程序本质上是一个算法，告诉计算机确切的步骤来执行一个特定的任务；

> 程序 = 算法 + 数据结构 （+ 程序设计方法 + 编程语言 + 编程环境）

展开来讲，程序就是基于特定的编程语言，在特定的编程环境下，采用特定的程序设计方法，由算法和数据结构组成的；

#### 常见算法思想

- 枚举算法

枚举算法思想：

将问题的所有可能答案一一列举，然后根据条件判断此答案是否合适；

基本步骤：

1. 确定枚举的对象、枚举范围和判定条件
2. 逐一列举可能的解，验证解是否是问题的解

注意点：

使用枚举算法时，要注意，

1. 不要遗漏或重复枚举范围的任意值
2. 判定条件是否正确
3. 能否适当缩小枚举范围以提高算法效率

- 递推算法

递推算法思想：

根据已知某个条件，利用特定关系得到中间推论，然后逐步递推，直到得到结果为止；

递推算法优于枚举算法之处在于不会尝试每种可能的方案；

递推算法种类：

1. 顺推法

从已知条件，逐步推算出解决问题的方法；

2. 逆推法

从已知结果出发，利用迭代表达式推算出问题开始条件；

- 递归算法

递归算法思想：

把问题转化为规模缩小了的同类问题的子问题，然后再递归调用函数来表示问题的解；

注意点：

1. 必须有一个明确的递归结束条件
2. 递归算法虽然编程上较为简洁，但是运行效率较低
3. 递归调用需要保存每一层的调用位置和内部变量，如果递归次数过多，会造成栈溢出；

- 分治算法

分治算法思想：

将规模较大的问题分解为若干个规模较小的子问题，这些子问题各自独立且与原问题性质相同，只要求出这几个子问题的解法后，再将它们组合成整个大问题的解；

- 贪心算法

贪心算法思想：

在求解问题时总想用当前看来是最好的解法，不从整体上考虑最优解，仅从某种意义求局部最优解；

具体步骤是：

1. 将求解问题分成若干个子问题
2. 对每一个子问题求解，得到子问题的局部最优解
3. 把子问题的局部最优解合并成原来问题的一个解

- 试探算法

试探算法思想：

该算法暂时放弃关于问题规模大小的限制，将问题的候选解按某种顺序逐一进行枚举和检验；

当发现候选解不是正确解时，则选择下一个候选解；

如果当前候选解除了不满足问题规模外能满足所有其他要求时，则继续扩大当前候选解的规模，继续试探；

如果当前候选解满足包括问题规模在内的所有要求，则该候选解就是问题的解；

在试探算法中，放弃当前候选解并继续寻找下一个候选解的过程叫做回溯；

扩大当前候选解的规模并继续试探称为向前试探；

- 迭代算法

迭代算法思想：

迭代算法是一种不断用变量的旧值递推新值的过程，直到新值符合条件为止；

基本步骤：

1. 确定迭代变量

即直接或间接由旧值递推出新值的变量；

2. 建立迭代关系式

即变量如何从前一个值推出其下一个值的公式，这个迭代关系式是解决迭代问题的关键；

3. 对迭代过程的控制

必须确定在什么时候结束迭代过程；

注意点：

- 与迭代法相对应的是直接法，即一次性解决问题；

- 迭代法又分为精确迭代和近似迭代

二分法为近似迭代；

- 模拟算法

模拟算法思想：

模拟是对真实事物或者过程的虚拟，在编程时为了实现某个功能，可以用特定编程语言模拟其功能；

比如常用随机函数来模拟自然界中发生的不可预测的情况；

### 什么是数据结构

算法处理的对象是数据，这些数据都是按照一定的规则进行组织，当这些数据之间存在一种或多种关系时，将这些组合起来的数据称之为**数据结构**；

#### 数据结构的种类

一般存在 2 大类基本结构：

##### 逻辑结构

逻辑结构细分为 4 类：

- 集合结构

数据元素同属一个集合，但彼此间没有关系

```yml
集合
字典
散列
```

- 线性结构

数据元素间是一对一关系

线性表：

各数据元素之间是一对一的关系，除了第一个和最后一个数据元素外，其他数据元素都是首尾相接的；

```yml
线性表
  数组
  字符串
  栈
  队列
```

- 树形结构

数据元素间是一对多关系

- 网状结构

数据元素间是多对多关系

##### 物理结构（存储结构）

- 顺序存储结构

数据元素存储在一段连续的内存空间

优点：随机访问，读取效率高
缺点：写入和删除效率低，空间大小固定

- 链式存储结构

数据元素存储在不连续的内存空间

优点：写入和删除效率高
缺点：无法随机访问，读取效率偏低

- 索引结构

数据元素存储需要额外借助索引表；

索引存储在索引表且有序，数据元素存储在主表可以无序

优点：对顺序存储的一种改进，查找效率高
缺点：需要额外存储空间存储索引

- 散列结构

基于散列函数，计算出数据元素的存储位置，从而是计算出的 hash 值与数据元素相对应；

优点：读写效率高；
缺点：不便于顺序查找

[link](https://blog.csdn.net/qq_39385118/article/details/80835048)