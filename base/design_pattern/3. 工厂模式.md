# 工厂模式

定义一个用于创建对象的接口（抽象工厂），让子类（实现类）决定实例化哪一个类；

具体来说，抽象产品类 Product 负责定义产品的共性，实现对事物的最抽象的定义；Creator 为抽象创建类，具体如何创建产品类由具体的实现工厂类 ConcreteCreator 完成；

## 优点

- 良好的封装性，代码结构清晰

创建一个具体的产品类，调用者只需要知道这个产品的类就行，不用知道创建对象的过程；

- 良好的扩展性

在增加产品类时，只需要增加一个产品的实现类，工厂类不变，就可以完成系统扩展；

- 屏蔽产品的实现类

产品的实现类无论如何变化，调用者都不用关心，只关心产品的接口；

只要接口不变，系统的上层模块就无需改变；

工厂模式是典型的解耦框架，高层模块只需要知道产品的抽象类，其他实现类无需关心，符合迪米特原则；

只依赖于产品的抽象类，符合依赖倒置原则；

使用产品子类替换产品父类，符合里氏替换原则原则；

## 使用场景

需要灵活的、可扩展的框架时，可考虑采用工厂模式，如基于 3 种邮件协议的连接邮件服务器的框架；

## 工厂模式的扩展

1. 缩小为简单工厂模式

如果一个模块仅需要一个工厂类，并且该工厂类不会发生太大的变化，无需扩展，可以考虑使用简单工厂模式（静态工厂模式）；

2. 升级为多个工厂类

当产品类具有多个是，并且生成产品对象过程可能存在差异，可以考虑使用多工厂模式；

3. 替代单例模式

通过单例工厂生成单例

4. 延迟初始化

一个对象创建和消费后，并不立即释放，工厂类保持其初始状态，等待再次被使用；

见 ProductFactory.java;