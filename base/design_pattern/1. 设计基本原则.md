# 设计基本原则

设计模式是可复用的解决软件设计问题的一般方案；

## 1. 单一职责原则（Single Responsibility Principle）

单一职责原则：有且仅有一个原因引起类或接口的变更

具体来讲，一个类或接口只负责一个事情，只有一个原因引起变化；

如果引起一个接口变化的原因不止一个，那么这个设计就不符合单一职责原则；

对于接口，设计时一定要做到单一，但对于实现类就需要多方面考虑，如果生搬硬套单一职责原则会引起类的剧增从而带来维护上的困难；

单一职责使用与接口、类，同时也适用于方法；

总之，一个遵循单一职责原则的类的设计，可以从接口层面划分不同的职责，在接口具体属性和方法的实现上，也要遵循单一职责。

## 2. 里氏替换原则（Liskov Substitution Principle, LSP）

里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象

具体来讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常；

LSP 为良好的继承定义了一个规范，包含 4 层定义：

- 子类必须完全实现父类方法

- 子类可以有自己的个性

- 覆盖或实现父类的方法时输入参数可以放大?

- 覆写或实现父类的方法时输出结果可以被缩小

里氏替换原则的目的是增强程序的健壮性，在版本升级时也可以保持良好的兼容性；

## 3. 依赖倒置原则（Dependence Inversion Principle DIP）

依赖倒置定义：

- 高层模块不依赖于低层模块，二者依赖其抽象

- 抽象不依赖细节

- 细节依赖抽象

每个逻辑都应该是原子逻辑（遵循单一职责原则），不可分割的原子逻辑就是低层模块，低层模块的再组装就是高层模块；

在 Java 语言中，抽象就是接口或抽象类，细节就是实现类；

依赖倒置原则的精简定义就是“面向接口编程”；

### 依赖对象传递的 3 种写法

- 构造函数传递依赖对象

这种依赖对象的注入方式适用于该依赖对象对被注入对象是必不可少的；

```java
public interface IDriver {
    public void drive();
}

public class Driver implements IDriver {
    private ICar car;

    public Driver(ICar _car) {
        this.car = _car;
    }

    public void driver() {
        car.run();
    }
}
```

- Setter 方法传递依赖对象

在抽象中设置 Setter 方法声明依赖对象，这种方式适合用于动态设置依赖对象的情形；

```java
public interface IDriver {
    public void setCar(ICar car);

    public void drive();
}

public class Driver implements IDriver {
    private ICar car;

    public void setCar(ICar car) {
        this.car = car;
    }

    public void drive() {
        car.run();
    }
}
```

- 接口声明依赖对象（接口注入）

```java
interface ICar {
    public void run();
}

interface IDriver {
    public void drive(ICar car);
}

class Driver implements IDriver {
    public void drive(ICar car) {
        car.run();
    }
}
```

### 最佳实践

- 每个类尽量都有接口或抽象类

有了抽象才可能进行依赖倒置

- 变量的表面类型尽量是接口或抽象类

- 任何类都不应该从具体类派生

- 尽量不要覆写基类的方法

如果基类是一个抽象类并且这个方法已实现，子类尽量不要覆写。覆写抽象方法，对依赖的稳定性会产生一定的影响；

依赖倒置原则是 6 个设计原则中最难实现的原则，是实现开闭原则的重要途径。

依赖倒置原则的核心思想是讲类间的依赖通过接口或抽象类进行抽象，实现方法是“面向接口编程”。

## 4. 接口隔离原则

接口隔离原则是指客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上；

接口隔离原则的核心在于接口或类的设计应该尽量精简，通俗讲就是接口方法尽量少，不要设计一个庞大臃肿的接口；

接口隔离原则具体内涵为：

- 接口要尽量小

接口隔离原则拆分接口时，事先必须满足单一职责原则

- 定制服务

一个系统内的模块之间必然存在耦合，有耦合就有相互访问的接口，因此在设计时需要为各个访问者定制服务，即只提供访问者需要的方法；

图书管理系统：公网和内网图书查询接口

- 接口设计是有限度的

简而言之，接口隔离原则就是设计接口的粒度。

代码见：Searcher.java

[note]

java中的super关键字是一个引用变量，用于引用直接父类对象。每当创建子类的实例时，父类的实例被隐式创建，由super关键字引用变量引用。java super关键字的用法如下：super可以用来引用直接父类的实例变量。super可以用来调用直接父类方法。super()可以用于调用直接父类构造函数。

## 5. 迪米特法则（Law of Demeter, LoD）最少知识原则

一个对象（类）应该对自己需要耦合或调用的对象（类）知道得最少，你内部是如何复杂和我没关系，我只要知道你提供这个多 public 方法就行了。

每个对象必然会与其他对象有耦合关系（朋友关系），这种关系可以分为组合、聚合、依赖等

迪米特法则具体含义包括：

- 只和朋友交流

只与直接的朋友通信，朋友类出现在类中的成员变量、方法的输入输出参数，如果出现在方法体内部的类就不属于朋友类，将会破坏代码的健壮性；

见 TeacherClient.java

- 朋友间也是有距离的

一个类的 public 属性或方法越多，修改时涉及面就越大，变更引起的风险扩散也就越大；

因此，为了保持朋友类间的距离，在设计时尽量不要对外公布太多的 public 方法，多用 private、package-private(变量前不加访问权限，则默认为包类型。声明为package-private 的成员则只能在包内被使用)、protected 等访问权限。

见 InstallWizardClient.java

- 是自己的就是自己的

如果遇到一个方法放在本类中可以，放在其他类也没错，可遵循以下原则：
    如果一个方法放在本类，既不增加类间关系，也对本类不产生负面影响，则放在本类中

迪米特原则的核心就是类间解耦，让类间的关系成为朋友类。

但是，遵循这一方法的结果就是产生大量的中转或跳转类，导致系统的复杂性提高，一般来说类间的跳转次数尽量控制在 2 次之内；

## 开闭原则（Open Closed Principle)

软件实体（类、模块或函数）应该对扩展开放，对修改关闭；

具体来说，软件实体通过扩展来实现变化，而不是通过修改已有代码来实现变化，尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性；

[note]

static{}(即static块)，会在类被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法。

代码见：BookStoreClient.java

开闭原则是最基础的一个原则，前五个原则都是开闭原则的具体形态；

### 为什么要采用开闭原则

- 开闭原则对测试的影响

- 开闭原则可以提高复用性

- 开闭原则可以提高可维护性

- 面向对象开发的要求

### 如何实践开闭原则

- 抽象约束

通过接口或抽象类去约束一组可能的变化，并能够实现对外扩展开放，不允许出现在接口或抽象类中不存在的 public 方法；

参数类型、引用对象尽量使用接口或者抽象类而不是实现类，而不是实现类，抽象层尽量保持稳定，一旦确定就不允许随便修改；

接口是与其他模块交流的契约，修改契约等于让其他模块修改，接口或抽象类一旦定义，就应该立即执行，不能有修改接口的思想；

见 book P102

- 元数据控制模块行为

元数据是用来描述环境和数据的数据，通俗来说就是配置参数；

- 制定项目章程

团队开发中，建立项目章程非常重要，约定由于配置；

- 封装变化

将相同的变化封装到一个接口或抽象类，将不同的变化封装到不同的接口或抽象类；

23 个设计模式都是从各个不同的角度对变化进行封装；

软件设计最大的难题就是应对需求变化，6 大设计原则和 23 个设计模式可以用来封装未来的变化；

### 小结

6 大设计原则可以归纳为：

在软件设计过程中，

首先要遵循开闭原则，即通过对原有接口（契约）扩展方式去实现扩展，而不是修改原有的接口；（总体）

其次，在设计接口或抽象类、方法、模块时，要遵循单一职责原则，引起前述实体变化的原因只有一个；（类）

紧接着，在设计类时，要遵循依赖倒置原则，即“面向接口编程”，将类间的依赖通过接口连接；（类、类间关系）

同时，在设计类时，需要遵循接口隔离原则，找到合适的划分接口的粒度；（类）

并且，类间要实现解耦，让类间的关系成为朋友类，即遵循迪米特法则；（类间关系）

最后，要遵循里氏替换原则，只要父类能出现的地方子类就可以出现；（类间关系）

即 SOLID 原则

## Extras

### 重写与重载

重写（Override）：覆盖与父类相同的方法名和输入参数

重写一般发生在子类继承父类过程中

重载（Overload）：覆盖与父类相同的方法名，但输入参数的类型不同

重载既可发生在子类继承父类过程中，也可发生在同一个类中的相同方法名，但不同的参数列表

### 表面类型与实际类型

在 Java 中，定义变量必然要有类型，类型分两种——表面类型和实际类型，表面类型是定义时赋予的类型，实际类型是对象的类型，如：

```java
interface IDriver {
    public void drive(ICar car);
}

class Driver implements IDriver {
    public void drive(ICar car) {
        car.run();
    }
}

public class Client {
    public static void main(String[] args) {
        // IDriver 是表面类型，new Driver() 的 Driver 是实际类型
        IDriver teren = new Driver();
        ICar benz = new Benz();
        teren.drive(benz);
    }
}
```

### 单元测试

业务逻辑测试

边界条件测试

异常测试

### 五大基本原则

- 单一职责原则

职责指的是代码的基本单元（类、对象或方法）在系统中所起的作用，即这段代码能干什么；

而单一职责是指代码的基本单元所发挥的作用是单一的，并且引起代码的基本单元的变化因素也是单一；

之所以这样设计，是因为如果代码基本单元的职责不是单一的话（存在耦合），那么一旦其中一个影响代码基本单元的因素发生改变，在修改该代码的基本单元时会对内部其他代码产生影响；

单一职责在类、对象和方法各层面上有不同的内涵，对于类和对象而言，单一职责意味着扮演的角色是单一的，对于方法而言执行的任务指向是单一的；

**单一职责原则的核心在于如何识别和分离出目标对象的职责**

**最佳实践**

首先要明确，并不是所有的职责都应该一一分离，如果两种职责是相伴相生关系则反而要耦合一起，例如发送 ajax 请求中的创建 xhr 和发送 xhr；

有时候会有意地违反 SRP 原则，因为这样暴露的接口或许对用户更加友好，比如 jQuery 的 attr 方法将取值和设值放在一起，因此需要在方便性和稳定性之间权衡；

**优缺点**

优点是降低单个类或对象的复杂度，按照职责将对象分解为更细粒度，有助于代码复用和单元测试，实现低耦合；

缺点是由于细粒度导致类或对象增加，从而会提高对象之间通信的复杂度；

- 最少知识原则

- 开放-关闭原则

OCP 是面向对象的程序设计中最重要的一条原则，良好的程序设计往往符合开放和关闭原则的；

对扩展开放，即变化部分通过扩展（增加代码方式）方式实现，对修改关闭，即将不变部分（通过发现变化、抽象变化、找出不变点、封装变化）进行封装并且不允许其修改

**变化点**

如果代码存在多个 if-else 语句，就有可能会存在违背开闭原则的情形；

**实现方式**

1. 利用对象的多态性实现

```js
let personSpeak = person => person.speak()

let White = function() {}
White.prototype.speak = function() {}
let Black = function() {}
Black.prototype.speak = function() {}

personSpeak(White)
personSpeak(Black)

```

2. 放置钩子

通过埋钩子，可以在子类需要变化情形下触发钩子生效，从而改变程序走向；

3. 使用回调函数

通过回调函数，将变化封装在回调函数中进行扩展；

