# 代理模式（委托模式）

## 定义

为其他对象提供一种代理以控制对该对象的访问；

代理是有个性的，代理的目的是在目标对象方法的基础上增强，即对目标对象的方法进行拦截和过滤；

## 分类

保护代理：代理类可以直接屏蔽掉某些请求

虚拟代理：把一些开销恨到的对象延迟到真正需要它时才去创建



## 使用场景

如果完成一件事情，处理被代理的功能外，还涉及事前和事后的其他功能，则可以考虑使用代理模式，具体包括：

- 数据校验

预先校验数据类型

- 权限校验

检验客户端操作是否有权限

- 缓存

进入委托者操作时可以进行缓存判断

- 懒加载

虚拟代理实现图片的懒加载

- 日志

...

## 扩展

- 普通代理

普通代理要求用户知道代理类存在，然后才能访问；

它要求客户端只能访问代理角色，而不能访问真实角色；

- 强制代理

调用者直接调用真实角色，而不用关心代理是否存在；

你必须通过真实角色查找到代理角色，否则你不能访问；

- 动态代理

## 小结

代理模式的本质是代理类和委托类实现同一个接口（或继承同一个抽象类），代理对象持有对委托对象的引用，外部调用时操作的是代理对象，代理对象内部实际操作的是委托对象；

动态代理模式其实就是 AOP 编程的实现，委托者专注“核心关注点”，实现核心功能逻辑，动态代理专注于”横切关注点“，实现代理职责和横切入诸如”日志、事务和权限“等功能；

## Extras

代理机制

代理机制描述的是：

通过代理类帮助被代理类实现其职能

好处在于：
    1. 可以隐藏委托类的实现
    2. 可以实现客户和委托类间的解耦

### 静态代理

代理类在程序运行前就已经存在，这种代理方式称为静态代理；

静态代理的局限在于运行前必须编写好代理类；

### 动态代理

代理类在运行时创建的代理方式称为动态代理，代理类并不在 Java 代理中定义，而是在运行时根据在 Java 代码中的指示动态生成；

动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数；

